---
title: "ErrorB Correction"
author: "Ziwei Crystal Zang"
date: "9/30/2019"
output: html_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(spatstat.utils)
library(mosaic)

library(cranium)

```

```{r}
path = "Sample/YouToo"
file_names <- list.files(path, pattern=".h5", full.names=TRUE)


brain_yt_3 <-read_h5(file_names[3])
tidy_brain_yt_3 <- tidy.brain(brain_yt_3, threshold.n = 0.6, type="youtoo")
ro_tidy_brain_yt_3 <- tidy_brain_yt_3%>%
  reorient()

plot2d(ro_tidy_brain_yt_3 , title = "Youtoo Sample #3 - After PCA-step 1") #output image with dimension: 900*300

is_errorB(ro_tidy_brain_yt_3)
```

# Function: is_errorB
```{r}
data <- tidy_brain_yt_3
type="wildtype"
threshold.n=0.6
range_ref = "outlier"


ro_tidy_brain <- data%>%
  reorient()

quad_model_xz <- attr(ro_tidy_brain, "quad_mod_xz") #quadratic model y = x^2 + x
  
quad.slope_xz = round((summary(quad_model_xz)$coefficients["I(x^2)", "Estimate"]), 5)

quad.slope_xz

if (range_ref == "outlier"){
     range <- c(-0.00202, 0.00182)
}else if (range_ref == "quantile"){
     range <- c(-0.00058, 0.00038)
}else if (range_ref== "ci"){
     range <- c(-0.0003206473, 0.0001243682)
}

range 
inside.range(quad.slope_xz, range)

```

# Function: correct_errorB
```{r}
ro_data <- ro_tidy_brain_yt_3
type = "youtoo"
threshold.n=0.6
r_angle_mpt=1

#extract quadratic model coefficients from xy plane
ro_model <- attr(ro_data, "quad_mod_xz")
quad.coeff = round((summary(ro_model)$coefficients["I(x^2)", "Estimate"]), 4)  #a

message("Beofre rotation, the quadratic coefficient is", " ", quad.coeff, ".")

x.coeff = round((summary(ro_model)$coefficients["x", "Estimate"]), 4)#b
intercept = round((summary(ro_model)$coefficients["(Intercept)", "Estimate"]), 4) #c

# y intercept
y_intercept <- intercept
# x intercept
x_intercept <- (-x.coeff + sqrt(x.coeff^2 - 4* quad.coeff * intercept))/ (2*quad.coeff)

  #vertex (x)
  #  vertex.x <- -x.coeff/(2*quad.coeff)
  # vertex.y <- quad.coeff * (vertex.x ^ 2) + x.coeff * vertex.x + intercept
  # vertex <- c(vertex.x, vertex.y)

  #slope of the line connecting m and n
  slope <- abs(y_intercept/x_intercept)
  #slope to angle (radian)
  rotation_angle_radian <- r_angle_mpt * atan(slope)
  #radian to degree
  rotation_angle_degree <- rad2deg(rotation_angle_radian)

  matrix.x <- diag(3)
  matrix.x[2,2] <- cos(rotation_angle_radian)
  matrix.x[2,3] <- -sin(rotation_angle_radian)
  matrix.x[3,2] <- sin(rotation_angle_radian)
  matrix.x[3,3] <- cos(rotation_angle_radian)

  data.matrix<-data%>%
    select(x,y,z)%>%
    as.matrix()

  data_freq_gray<- data%>%
    select(Freq,gray_val)

  r.data <- data.matrix %*% matrix.x %>%
    tibble::as_tibble() %>%
    bind_cols(data_freq_gray)

  names(r.data) <- names(data)

  class(r.data) <- append("tbl_brain", class(r.data))

  attr(r.data, "quad_mod_xy") <- stats::lm(y ~ x + I(x^2), data =r.data)
  attr(r.data, "linear_mod_xy") <- stats::lm(y ~ x, data=r.data)
  #xz plane
  attr(r.data, "quad_mod_xz") <- stats::lm(z ~ x + I(x^2), data = r.data)
  attr(r.data, "linear_mod_xz") <- stats::lm(z ~ x, data=r.data)
  #yz plane
  attr(r.data, "quad_mod_yz") <- stats::lm(z ~ y + I(y^2), data = r.data)
  attr(r.data, "linear_mod_yz") <- stats::lm(z ~ y, data=r.data)


  #check the quadratic coefficient after rotation
  r.ro_model <- attr(r.data, "quad_mod_xz")
  r.quad.coeff = round((summary(r.ro_model)$coefficients["I(x^2)", "Estimate"]), 4)  #a
  message("After rotation, the quadratic coefficient is", " ", r.quad.coeff, ".")

  return(r.data)


```


